---
title: Strings
localeTitle: Строки 
---
## Строки 

Строка (тип string) - это набор символов, где символ - это то же самое, что и байт. Это значит, что PHP поддерживает ровно 256 различных символов, а также то, что в PHP нет встроенной поддержки Unicode. Смотрите также подробности реализации строкового типа. 

## Синтаксис 
 Строка может быть определена четырьмя различными способами:

* одинарными кавычками
* двойными кавычками
* heredoc-синтаксисом
* nowdoc-синтаксисом (начиная с PHP 5.3.0)

### Одинарные кавычки

Простейший способ определить строку - это заключить ее в одинарные кавычки (символ ').

Чтобы использовать одинарную кавычку внутри строки, проэкранируйте ее обратным слешем (\). Если необходимо написать сам обратный слеш, продублируйте его (\\). Все остальные случаи применения обратного слеша будут интерпретированы как обычные символы: это означает, что если вы попытаетесь использовать другие управляющие последовательности, такие как \r или \n, они будут выведены как есть вместо какого-либо особого поведения. 

### Двойные кавычки

Если строка заключена в двойные кавычки ("), PHP распознает следующие управляющие последовательности специальных символов: 

Последовательность  | Значение
------------------- | -------------
\n                  | новая строка (LF или 0x0A (10) в ASCII)
\r                  | возврат каретки (CR или 0x0D (13) в ASCII)
\t                  | горизонтальная табуляция (HT или 0x09 (9) в ASCII)
\v                  | вертикальная табуляция (VT или 0x0B (11) в ASCII) (с PHP 5.2.5)
\e                  | escape-знак (ESC или 0x1B (27) в ASCII) (с PHP 5.4.4)
\f                  | подача страницы (FF или 0x0C (12) в ASCII) (с PHP 5.2.5)
\\                  | обратная косая черта
\$                  | знак доллара
\"                  | двойная кавычка
\[0-7]{1,3}         | последовательность символов, соответствующая регулярному выражению символа в восьмеричной системе счисления, который молча переполняется, чтобы поместиться в байт (т.е. "\400" === "\000") 
\x[0-9A-Fa-f]{1,2}  | последовательность символов, соответствующая регулярному выражению символа в шестнадцатеричной системе счисления 
\u{[0-9A-Fa-f]+}    |последовательность символов, соответствующая регулярному выражению символа Unicode, которая отображается в строка в представлении UTF-8 (добавлено в PHP 7.0.0) 

 Как и в строке, заключенной в одинарные кавычки, экранирование любого символа выведет также и сам символ экранирования. До версии PHP 5.1.1, обратный слеш в \{$var} не печатался.

Но самым важным свойством строк в двойных кавычках является обработка переменных. 

### Heredoc 

 Третий способ определения строк - это использование heredoc-синтаксиса: <<<. После этого оператора необходимо указать идентификатор, затем перевод строки. После этого идет сама строка, а потом этот же идентификатор, закрывающий вставку.

Строка должна начинаться с закрывающего идентификатора, т.е. он должен стоять в первом столбце строки. Кроме того, идентификатор должен соответствовать тем же правилам именования, что и все остальные метки в PHP: содержать только буквенно-цифровые символы и знак подчеркивания, и не должен начинаться с цифры (знак подчеркивания разрешается). 

`Внимание

Очень важно отметить, что строка с закрывающим идентификатором не должна содержать других символов, за исключением точки с запятой (;). Это означает, что идентификатор не должен вводиться с отступом и что не может быть никаких пробелов или знаков табуляции до или после точки с запятой. Важно также понимать, что первым символом перед закрывающим идентификатором должен быть символ новой строки, определенный в вашей операционной системе. Например, в UNIX системах, включая macOS, это \n. После закрывающего идентификатора также сразу должна начинаться новая строка.

Если это правило нарушено и закрывающий идентификатор не является "чистым", считается, что закрывающий идентификатор отсутствует и PHP продолжит его поиск дальше. Если в этом случае верный закрывающий идентификатор так и не будет найден, то это вызовет ошибку парсинга с номером строки в конце скрипта. `

Heredoc-текст ведет себя так же, как и строка в двойных кавычках, при этом их не имея. Это означает, что вам нет необходимости экранировать кавычки в heredoc, но вы по-прежнему можете использовать вышеперечисленные управляющие последовательности. Переменные обрабатываются, но с применением сложных переменных внутри heredoc нужно быть также внимательным, как и при работе со строками. 

### Nowdoc 

Nowdoc - это то же самое для строк в одинарных кавычках, что и heredoc для строк в двойных кавычках. Nowdoc похож на heredoc, но внутри него не осуществляется никаких подстановок. Эта конструкция идеальна для внедрения PHP-кода или других больших блоков текста без необходимости его экранирования. В этом он немного похож на SGML-конструкцию <![CDATA[ ]]> тем, что объявляет блок текста, не предназначенный для обработки.

Nowdoc указывается той же последовательностью <<<, что используется в heredoc, но последующий за ней идентификатор заключается в одинарные кавычки, например, <<<'EOT'. Все условия, действующие для идентификаторов heredoc также действительны и для nowdoc, особенно те, что относятся к закрывающему идентификатору. 

## Обработка переменных

 Если строка указывается в двойных кавычках, либо при помощи heredoc, переменные внутри нее обрабатываются.

Существует два типа синтаксиса: простой и сложный. Простой синтаксис более легок и удобен. Он дает возможность обработки переменной, значения массива (array) или свойства объекта (object) с минимумом усилий.

Сложный синтаксис может быть определен по фигурным скобкам, окружающим выражение. 

### Простой синтаксис
Если интерпретатор встречает знак доллара ($), он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. Если вы хотите точно определить конец имени, заключайте имя переменной в фигурные скобки. 

### Сложный (фигурный) синтаксис
 Он называется сложным не потому, что труден в понимании, а потому что позволяет использовать сложные выражения.

Любая скалярная переменная, элемент массива или свойство объекта, отображаемое в строку, может быть представлена в строке этим синтаксисом. Просто запишите выражение так же, как и вне строки, а затем заключите его в { и } . Поскольку { не может быть экранирован, этот синтаксис будет распознаваться только когда $ следует непосредственно за {. Используйте {\$, чтобы напечатать {$. 

`Замечание:

Функции, вызовы методов, статические переменные классов, а также константы классов работает внутри {$}, начиная с версии PHP 5. Однако, указываемое значение будет обработано как имя переменной в том же контексте, что и строка, в которой она определяется. Использование одинарных фигурных скобок ({}) не будет работать для доступа к значениям функций, методов, констант классов или статических переменных класса. `

#### Дополнительная информация:

