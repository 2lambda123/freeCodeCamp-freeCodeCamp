---
id: 64df3f1011888113fbd3d81b
title: Step 42
challengeType: 20
dashedName: step-42
---

# --description--

To solve the puzzle with recursion, the first thing to do is breaking the original problem down into smaller sub-problems.

The final configuration with `n` disks piled up to the third rod in descreasing order can be obtained by moving:

- `n -1` disks from the source to the auxiliary rod
- the largest disk from the source to the target
- and then the `n -1` disks from the auxiliary rod to the target.

So, the first thing the `move` function should do is calling itself with `n - 1` as the first parameter. But if you try to do so without defining a base case, you will get a `RecursionError`. This happens because the function keeps calling itself indefinitely. 

Before your `print` statement, add the recursive function call and make sure the function body executes only when `n` is greater than zero. For now, leave the others parameters in the same order.

# --hints--

Test 1

```js

```

# --seed--

## --seed-contents--

```py
NUMBER_OF_DISKS = 4
rods = {
    'A': list(range(NUMBER_OF_DISKS, 0, -1)),
    'B': [],
    'C': []
}

--fcc-editable-region--
def move(n, source, target, auxiliary):
    # display starting configuration
    print(rods, '\n')
              
--fcc-editable-region--
# initiate call from source A to target C with auxiliary B
move(NUMBER_OF_DISKS, 'A', 'C', 'B')
```
