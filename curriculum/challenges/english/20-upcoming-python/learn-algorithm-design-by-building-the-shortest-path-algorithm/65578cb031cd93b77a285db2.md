---
id: 65578cb031cd93b77a285db2
title: Step 21
challengeType: 20
dashedName: step-21
---

# --description--

Your function is going to explore all the nodes connected to the starting nodes. It will calculate the shortest paths for all of them and then, it will remove the starting node from the unvisited nodes. Next, the closest neighbour node is visited and the process gets repeated until all the nodes are visited.

From now on, you are going to work on the main loop that explores the nodes in the provided graph. To avoid issues with running a temporary infinite loop during the algorithm development, turn your function call into a comment.

# --hints--

Test 1

```js

```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--
my_graph = {
    'A': [('B', 5), ('C', 3), ('E', 11)],
    'B': [('A', 5), ('C', 1), ('F', 2)],
    'C': [('A', 3), ('B', 1), ('D', 1), ('E', 5)],
    'D': [('C',1 ), ('E', 9), ('F', 3)],
    'E': [('A', 11), ('C', 5), ('D', 9)],
    'F': [('B', 2), ('D', 3)]
}

def shortest_path(graph, start):
    unvisited = list(graph)
    distances = {node: 0 if node == start else float('inf') for node in graph}
    paths = {node: [] for node in graph}
    paths[start].append(start)
    
    print(f'Unvisited: {unvisited}\nDistances: {distances}\nPaths: {paths}')
    
shortest_path(my_graph, 'A')
--fcc-editable-region--
```
