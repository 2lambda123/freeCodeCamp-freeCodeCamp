---
id: 65578d4fc3afc3b8f554c882
title: Step 26
challengeType: 20
dashedName: step-26
---

# --description--

The line you've just written in the previous step set `current` as the smallest item among the unvisited nodes. The result will be the node that comes first in alphabetical order. Instead you want to select the unvisited node having the smallest distance from the starting node. 
`min()` takes also a keyword-only argument. Passing a function as an additional argument to `min()`, you can modify the way the list items are compared.
Pass `key=distances.get` as the second argument to your `min()` call. In this way, the comparison will take place depending on the value each `unvisited` list item has inside the `distances` dictionary.

# --hints--

Test 1

```js

```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--
my_graph = {
    'A': [('B', 5), ('C', 3), ('E', 11)],
    'B': [('A', 5), ('C', 1), ('F', 2)],
    'C': [('A', 3), ('B', 1), ('D', 1), ('E', 5)],
    'D': [('C',1 ), ('E', 9), ('F', 3)],
    'E': [('A', 11), ('C', 5), ('D', 9)],
    'F': [('B', 2), ('D', 3)]
}

def shortest_path(graph, start):
    unvisited = list(graph)
    distances = {node: 0 if node == start else float('inf') for node in graph}
    paths = {node: [] for node in graph}
    paths[start].append(start)
    
    while unvisited:
        current = min(unvisited)
    
    print(f'Unvisited: {unvisited}\nDistances: {distances}\nPaths: {paths}')
    
#shortest_path(my_graph, 'A')
--fcc-editable-region--
```
