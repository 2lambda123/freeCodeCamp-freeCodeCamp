---
id: 662fa2e2cf27c09f21f4f5d0
title: Step 9
challengeType: 20
dashedName: step-9
---

# --description--

Inside the `Equation` class, define a new abstract method `grade`. Then, define it within the `LinearEquation` class to avoid errors.

# --hints--

You should define a method named `grade` within the `Equation` class.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").has_function("grade")`)) })
```

Your `grade` method should take one parameter, `self`.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("grade").has_args("self")`)) })
```

You should decorate with `@abstractmethod` the `grade` method within the `Equation` class.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("grade").has_decorators("abstractmethod")`)) })
```

You should define a method named `grade` within the `LinearEquation` class.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("LinearEquation").has_function("grade")`)) })
```

Your `grade` method should take one parameter, `self`.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("LinearEquation").find_function("grade").has_args("self")`)) })
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod
--fcc-editable-region--
class Equation(ABC):
    def __init__(self): pass
    
    @abstractmethod
    def solve(self): pass
        
    @abstractmethod
    def analyze(self): pass
        
class LinearEquation(Equation):
    def solve(self): pass
    
    def analyze(self): pass
--fcc-editable-region--
lin_eq = LinearEquation()
```
