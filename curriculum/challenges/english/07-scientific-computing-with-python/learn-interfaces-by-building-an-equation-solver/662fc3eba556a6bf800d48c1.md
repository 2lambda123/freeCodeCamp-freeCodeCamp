---
id: 662fc3eba556a6bf800d48c1
title: Step 14
challengeType: 20
dashedName: step-14
---

# --description--

Another thing you want to check is that every argument is a number. After your first `if`, create a `for` loop that iterates over `args` and checks if the argument at the current iteration is not an instance of `int` or `float`. If not, raise a `TypeError` saying `"Coefficients must be of type 'int' or 'float'"`.

# --hints--

You should create a `for` loop that iterates over `args` after your `if` statement.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_for_iter().is_equivalent("args")`)) })
```

You should create an `if` statement that checks if the current coefficient is not an instance of either `int` or `float` within the `for` loop.

```js
({ test: () => assert(runPython(`
var = str(_Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_for_vars())
cond1 = f'not isinstance({var}, (int, float))'
cond2 = f'not isinstance({var}, (int, float))'
if_stmt = _Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_ifs()[0].find_conditions()[0]
if_stmt.is_equivalent(cond1) or if_stmt.is_equivalent(cond2)
`)) })
```

You should use the provided string to raise a `TypeError` within the `if` statement.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("__init__").find_for_loops()[0].find_ifs()[0].find_bodies()[0].has_stmt("raise TypeError(\\"Coefficients must be of type 'int' or 'float'\\")")
`)) })
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod
--fcc-editable-region--
class Equation(ABC):   
    def __init__(self, *args):
        if (self.grade + 1) != len(args):
            raise TypeError(
                f"'{self.__class__.__name__}' object takes {self.grade + 1} positional arguments but {len(args)} were given"
            )
--fcc-editable-region--
    @property
    @abstractmethod
    def grade(self): pass    
    
    @abstractmethod
    def solve(self): pass
        
    @abstractmethod
    def analyze(self): pass
        
class LinearEquation(Equation):
    @property
    def grade(self):
        return 1
    
    def solve(self): pass
    
    def analyze(self): pass
    
lin_eq = LinearEquation(2, 3)
```
