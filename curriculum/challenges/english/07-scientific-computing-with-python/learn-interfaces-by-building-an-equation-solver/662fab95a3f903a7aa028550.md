---
id: 662fab95a3f903a7aa028550
title: Step 11
challengeType: 20
dashedName: step-11
---

# --description--

A property is a method that can be accessed as an attribute. The `property` decorator is used for this purpose:

```py
class Fish:
    @property
    def swim(self):
        return 'Swimming!'

trout = Fish()
trout.swim # Swimming!
```

In the example above, the `swim` property of `trout` is accessed throught `trout.swim` instead of `trout.swim()`, as it would be for a regular method.

Decorators can be combined with each other (by specifying them in separate lines before the method to decorate) to obtain enhanced functionalities.

Turn the `degree` method into a property. For that you'll need to use the `property` decorator in both classes and as the first decorator within the `Equation` class.

# --hints--

You should decorate with `@property` and `@abstractmethod` the `degree` method within the `Equation` class. The order matters.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("Equation").find_function("degree").has_decorators("property", "abstractmethod")`)) })
```

You should decorate with `@property` the `degree` method within the `LinearEquation` class.

```js
({ test: () => assert(runPython(`_Node(_code).find_class("LinearEquation").find_function("degree").has_decorators("property")`)) })
```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod
--fcc-editable-region--
class Equation(ABC):
    def __init__(self): pass
    
    @abstractmethod
    def degree(self): pass    
    
    @abstractmethod
    def solve(self): pass
        
    @abstractmethod
    def analyze(self): pass
        
class LinearEquation(Equation):
    def degree(self):
        return 1
--fcc-editable-region--
    def solve(self): pass
    
    def analyze(self): pass
    
lin_eq = LinearEquation()

```
