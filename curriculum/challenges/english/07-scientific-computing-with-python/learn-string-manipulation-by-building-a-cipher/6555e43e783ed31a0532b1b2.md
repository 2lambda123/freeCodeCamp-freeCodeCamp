---
id: 6555e43e783ed31a0532b1b2
title: Step 92
challengeType: 20
dashedName: step-92
---

# --description--

In programming, escaping characters within a string lets us include special characters that would otherwise have a different meaning in the language syntax. For Python, the escape character is a backslash `\`. Combining the escape character with an `n`, gives us the new line character, `\n`. When Python sees `\n` in a string, it will be replaced by a new line in the output when the program runs.

If you need to add quotes (`"` or `'`) within a string, you can use `\` to escape them (`\"` or `\'`). However, consider picking single or double quotes for the string and use the opposite for quotes inside to avoid escaping them. 

For example, if you need double quotes inside, surround your string with single quotes (e.x. `"This is a valid 'string'"`).

Add a newline at the start of your first print statement, and display the encrypted text in double quotes. Avoid escaping double quotes by choosing your string delimiters wisely.

Example output: For the encrypted text `abcde`, the output should read: 

```shell
>>> 
Encrypted text: "abcde"
>>> Key: python
```

# --hints--

To include a newline character at the beginning of the output, prepend `\n` to your string inside the print function.

```js
({ test: () => assert.match(code, /^print\s*\(\s*f("|')\\nEncrypted\stext:/m) })
```

Since you need to include double quotes around the encrypted text in the output, use single quotes to delimit your string. This way, you avoid needing to escape the double quotes.

```js
({ test: () => assert.match(code, /^print\s*\(\s*f'\\nEncrypted\stext:\s"\{\s*text\s*\}"'\s*\)/m) })
```

# --seed--

## --seed-contents--

```py
text = 'mrttaqrhknsw ih puggrur'
custom_key = 'python'

def vigenere(message, key, direction=1):
    key_index = 0
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    final_message = ''

    for char in message.lower():

        # Append any non-letter character to the message
        if not char.isalpha():
            final_message += char
        else:        
            # Find the right key character to encode/decode
            key_char = key[key_index % len(key)]
            key_index += 1

            # Define the offset and the encrypted/decrypted letter
            offset = alphabet.index(key_char)
            index = alphabet.find(char)
            new_index = (index + offset*direction) % len(alphabet)
            final_message += alphabet[new_index]
    
    return final_message

def encrypt(message, key):
    return vigenere(message, key)
    
def decrypt(message, key):
    return vigenere(message, key, -1)
--fcc-editable-region--
print(f'Encrypted text: {text}')
print(f'Key: {custom_key}')
--fcc-editable-region--
#decryption = decrypt(encryption, custom_key)
#print(decryption)
```

# --solutions--

```py
text = ''
print(f'\nEncrypted text: "{text}"')
```
