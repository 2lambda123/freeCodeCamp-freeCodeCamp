{
  "name": "Object Oriented Programming",
  "order": 6,
  "time": "5 hours",
  "helpRoom": "Help",
  "challenges": [
    {
      "id": "9d7123c01441eddfaeb5bdef",
      "title": "Create a basic JavaScript object",
      "description": [
        "Think about things we encounter in our everyday life, like cars, shops, and birds. These are all objects: tangible things we can observe and interact with.",
        "What are some qualities of these objects? A car has wheels. Shops sell items. Birds have wings. ",
        "These qualities, or properties, define what makes up an object. It's important to note that cars might all have wheels, but not all cars will have the same number of wheels.",
        "We can use objects in JavaScript to model real-world objects, endowing them with properties and behavior just like their real-world counterparts. We’ll use the previous concepts to create a “duck” object:",
        "<code>var duck = {</code>",
        "<code>  name: \"Aflac\",</code>",
        "<code>  numLegs: 2</code>",
        "<code>} </code>",
        "We created a “duck” object with two property/value pairs: a name of Aflac and a numLegs of 2.",
        "Instructions",
        "Create a “dog” object with name and numLegs properties, and set them to a string and a number, respectively."
      ],
      "challengeSeed": [
        "var dog = {",
        "  //Your code here",
        "}"
      ],
      "tests": [
        "assert(typeof(dog) === “object”), ‘message: Dog should be an object.’;",
        "assert(typeof(dog.name) === ‘string’), ‘message: dog.name should be a string;",
        "assert(typeof(dog.numLegs) === ‘number’), ‘message: dog.numLegs should be a number;"
      ],
      "solutions": [
        "var dog = {\n  name: //string,\n  numLegs: //number\n}"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c02441eddfaeb5bdef",
      "title": "Use Dot Notation to Access the Properties of an Object",
      "description": [
        "Great job on defining that “dog” object. Now that we have created an object, let's talk about accessing some of these properties!",
        "It's very simple to access the values of a property on an object. See the following example:",
        "<code>var duck = {</code>",
        "<code>  name: \"Aflac\",</code>",
        "<code>  numLegs: 2</code>",
        "<code>} </code>",
        "console.log(duck.name)",
        "//This will print \"Aflac\" to the console. ",
        "By using our object name, duck, along with the property whose value we want to utilize, color, we access the property of your object.",
        "Instructions",
        "Print the properties of the Dog object below to your console."
      ],
      "challengeSeed": [
        "var dog = {",
        "  name: “Spot”,",
        "  numLegs: 4",
        "}",
        "",
        "console.log(dog.name);",
        "console.log(dog.numLegs);"
      ],
      "tests": [
        "assert(console.log(dog.name) === “Spot”), ‘message: console.log(dog.name) should print out “Spot”",
        "assert(console.log(dog.numLegs) === 4), ‘message: console.log(dog.numLegs) should print out the number 4.’"
      ],
      "solutions": [],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c03441eddfaeb5bdef",
      "title": "Create a method on an object",
      "description": [
        "Now that we know how to create an object and access its properties, let's explore a special property of objects. Namely, we will talk about adding a method to our existing objects!",
        "Methods are properties that are functions. We can do all sorts of things with these methods. Let's look at the previous duck example, and add a method:",
        "<code>var duck = {</code>",
        "<code>  name: \"Aflac\",</code>",
        "<code>  numLegs: 2</code>",
        "<code>  sayName: function() {return \"The name of this duck is \" + duck.name + \".\"}</code>",
        "<code>} </code>",
        "duck.sayName();",
        "//This will return \"The name of this duck is Aflac.\"",
        "As you can see above, we added the sayName method, which is a function that we can call to return a sentence telling us the color of the duck. This is a straightforward method of adding a method to an object in JavaScript.",
        "Notice that we access the name of the duck in the method. We'll get back to that in the next lesson, but for now, this is the way we will insert that value into the string.",
        "Instructions",
        "In the following exercise, draw upon the previous “dog” object you created, and give it a method sayLegs. This method should return a sentence that says \"This dog has 4 legs.\""
      ],
      "challengeSeed": [
        "var dog = {",
        "  name: “Spot”,",
        "  numLegs: 4",
        "  //Add your method here.",
        "}",
        "",
        "dog.sayLegs();"
      ],
      "tests": [
        "assert(typeof(dog.sayLegs() === ‘function’), ‘message: dog.sayLegs() should be a function.’",
        "assert(dog.sayLegs() === “This dog has 4 legs.”), ‘message: dog.sayLegs() should return the desired string.’"
      ],
      "solutions": [
        "var dog = {\n  name: “Spot”,\n  numLegs: 4\n  sayLegs: function() {return \"This dog has \" + dog.legs + \" legs.\"}\n}\n\ndog.sayLegs();"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c04441eddfaeb5bdef",
      "title": "Make Code More Reusable with this",
      "description": [
        "We are going to look at our sayName method from the previous example",
        "<code>sayName: function() {return \"The name of this duck is \" + duck.name + \".\"}</code>",
        "Notice how we are referencing the variable name of our object, duck inside the sayName method in order to access the name property. While this is a totally valid way to access our object's property, there is a bit of a pitfall here.",
        "What if the variable name of our object changes? What if, instead of a duck, it's a mallard now? Well, we would have to change duck.name to mallard.name. In this small example, that's fine, but what happens when we have an object that makes many references to its properties throughout its methods? Now the process gets much more complex!",
        "There's a way to avoid that all. Introducing...this:",
        "<code>var duck = {</code>",
        "<code>  name: \"Aflac\",</code>",
        "<code>  numLegs: 2,</code>",
        "<code>  sayName: function() {return \"The name of this duck is \" + this.name + \".\"}</code>",
        "<code>} </code>",
        "This is a very robust topic that would be a great idea to research more deeply. For now, understand that this, in the current context, refers to the object that our method is associated with: duck.",
        "Now, if we changed our object's name to mallard, we don't have to find all our references to duck in our code. We've made our code more reusable and easy to read.",
        "Instructions",
        "Modify the dog.sayLegs method to remove any references to dog. It should follows the same code style as the duck object."
      ],
      "challengeSeed": [
        "var duck = {",
        "  name: \"Aflac\",",
        "  numLegs: 2,",
        "  sayName: function() {return \"The name of this duck is \" + this.name + \".\"}",
        "}; ",
        "",
        "",
        "// Modify code below this line. ",
        "",
        "var dog = {",
        "  name: “Spot”,",
        "  numLegs: 4,",
        "  sayLegs: function() {return \"This dog has \" + dog.numLegs + \" legs.\"}",
        "}; ",
        "",
        "dog.sayLegs();"
      ],
      "tests": [
        "assert(dog.sayLegs() === “This dog has 4 legs.”), ‘message: dog.sayLegs() should return the desired string.’"
      ],
      "solutions": [
        "var dog = {\n  name: “Spot”,\n  numLegs: 4,\n  sayLegs: function() {return \"This dog has \" + this.numLegs + \" legs.\"}\n}\n\ndog.sayLegs();"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c05441eddfaeb5bdef",
      "title": "Use a Mixin to add common behavior between unrelated objects",
      "description": [
        "As you have previously seen you can share behaviour through inheritance, but there are cases when inheritance is not the best solution. Inheritance does not work well for unrelated objects like Bird and Airplane. They can both fly, but a Bird is not a type of Airplane and vice versa.",
        "For unrelated objects, it's better to use mixins. A mixin allows a collection of functions to be used by other objects.",
        "<code>var flyMixin = function(obj) {</code>",
        "<code>    obj.fly = function() {</code>",
        "<code>        console.log(\"Flying, wooosh!\")</code>",
        "<code>    }</code>",
        "<code>}</code>",
        "The flyMixin takes any object and gives it the fly method.",
        "<code>var bird = {</code>",
        "<code>    name: “Donald”,</code>",
        "<code>    numLegs: 2,  </code>",
        "<code>}</code>",
        "<code></code>",
        "<code>var plane = {</code>",
        "<code>    model: “777”,</code>",
        "<code>    numPassengers: 524 </code>",
        "<code>}</code>",
        "",
        "<code>flyMixin(bird); </code>",
        "<code>flyMixin(plane); </code>",
        "Here bird and plane are passed into flyMixin, which then assigns the fly function to each object. Now bird and plane can both fly.",
        "",
        "<code>bird.fly(); //results in output on the screen: Flying, wooosh!</code>",
        "<code>plane.fly(); //results in output on the screen: Flying, wooosh!</code>",
        "Note how the mixin allows for the same fly method to be reused by completely unrelated objects bird and plane.",
        "Instructions",
        "Create a mixin named glideMixin’ that defines a method namedglide. Use theglideMixinto give bothbirdandboatthe ability toglide`."
      ],
      "challengeSeed": [
        "var bird = {",
        "    name: ‘Donald’, ",
        "    numLegs: 2,  ",
        "} ",
        "",
        "var boat = {",
        "    name: 'Warrior', ",
        "    type: 'race-boat',  ",
        "}",
        "",
        "// Only add code below this line."
      ],
      "tests": [
        "assert(/var glideMixin = function(.+)/.test(code), ‘message: Please use the `var glideMixin` and set it equal to an anonymous function’",
        "assert(typeof glideMixin === \"function\", ‘message: `glideMixin` should follow the proper structure of a function)",
        "assert(/glideMixin\\(.+\\)/.test(code), ‘message: Don’t forget to pass the object to your mixin, to give it access to `.glide` method’"
      ],
      "solutions": [
        "var glideMixin = function(obj) {\n    obj.glide = function() {\n        console.log(\"Gliding on the water\")\n    }\n}\n\nglideMixin(bird); \nglideMixin(boat); "
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c06441eddfaeb5bdef",
      "title": "Use closure to protect properties within an object from being modified externally",
      "description": [
        "In the previous challenge, bird had a public property name. We say it is public because it can be changed outside of the context of bird.",
        "<code>bird.name = \"Duffy\"</code>",
        "Any part of your code can therefore easily change the name of bird to any value. Think about things like passwords and bank accounts being easily changeable by any part of your codebase. That could be catastrophic.",
        "The simplest way to make properties private is by creating a var within the constructor function. In this way the private properties can only be accessed and changed by privileged methods within the constructor.",
        "<code>function Bird() { </code>",
        "<code>  var hatchedEgg = 10; // private property</code>",
        "<code></code>",
        "<code>  this.getHatchedEggCount = function() { //publicly available method that a bird object can use</code>",
        "<code>  return hatchedEgg();  </code>",
        "<code>  }</code>",
        "<code>}</code>",
        "<code>ducky = new Bird(); </code>",
        "<code>ducky.getHatchedEggCount() //returns 10</code>",
        "Here getHachedEggCount is a privileged method, because it has access to the private variable hatchedEgg. This is possible because hatchedEgg is declared in the same context as getHatchedEggCount. In javascript a function always has access to the context in which it was created. This is called closure.",
        "Instructions",
        "Change the function in the text editor to make the weight parameter private."
      ],
      "challengeSeed": [
        "// rewrite the function below",
        "function Bird() {",
        "  this.weight = 15; ",
        "}"
      ],
      "tests": [
        "assert(/var weight/.test(code), 'message: Please use the `var` before the weight to make it private'",
        "assert(/function handleWeight\\(\\) {/.test(code), 'message: Please make sure to create a named function within your Bird object' ",
        "assert(/return weight;/.test(code), 'message: Please remember to have a return statement for your private weight variable'",
        "assert(/this.getWeight = function\\(\\) {/.test(code), 'message: Make sure to have a public method that an instance of your `Bird` can call on'"
      ],
      "solutions": [
        "function Bird() { \n  var weight = 15; \n  function handleWeight() {\n    return weight; \n  }\n  this.getWeight = function() {\n    return handleWeight();  \n  }\n}"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c07441eddfaeb5bdef",
      "title": "Understand the immediately invoked function Expression (IIFE)",
      "description": [
        "A common pattern in javascript is to execute a function as soon as it is declared:",
        "<code>  (function () {</code>",
        "<code>    console.log(\"Chirp, chirp!\")</code>",
        "<code>  })(); // this is the anonymous function expression that executes right away</code>",
        "<code>// Outputs \"Chirp, chirp\" immediately</code>",
        "Note that the function has no name and is not stored in a variable. The two parentheses () at the end of the function expression cause it to be immediately executed or invoked. This pattern is known as an immediately invoked function expression or IIFE.",
        "Instructions",
        "Rewrite the function in the text editor to be an immediately invoked function expression (IIFE)."
      ],
      "challengeSeed": [
        "function makeNest() {",
        "    console.log(\"A cozy nest is ready\"); ",
        "}",
        "",
        "makeNest(); "
      ],
      "tests": [
        "assert(/\\(function\\(\\) {/.test(code), 'message: Make sure your new function is anonymous'",
        "assert(/}\\)\\(\\)/.test(code), 'message: Don’t forget to have double parentheses at the end of your function expression'"
      ],
      "solutions": [
        "(function() {\n    console.log(\"A cozy nest is ready\")\n})(); "
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c08441eddfaeb5bdef",
      "title": "Use an IIFE to create a module",
      "description": [
        "An immediately invoked function expression (IIFE) is often used to group related functionality into a single object or module. For example, in a previous section, we defined two mixins:",
        "<code>function glideMixin(obj) {</code>",
        "<code>      obj.glide = function() {</code>",
        "<code>        console.log(\"Gliding on the water\")</code>",
        "<code>      }</code>",
        "<code>}</code>",
        "<code>function flyMixin(obj) {</code>",
        "<code>      obj.fly = function() {</code>",
        "<code>        console.log(\"Flying, wooosh!\")</code>",
        "<code>      }</code>",
        "<code>}</code>",
        "We can group these mixins into a module as follows:",
        "<code>var motionModule = (function () {</code>",
        "<code>  return {</code>",
        "<code>    glideMixin: function (obj) {</code>",
        "<code>      obj.glide = function() {</code>",
        "<code>        console.log(\"Gliding on the water\")</code>",
        "<code>      }</code>",
        "<code>    }, </code>",
        "<code>    flyMixin: function(obj) {</code>",
        "<code>      obj.fly = function() {</code>",
        "<code>        console.log(\"Flying, wooosh!\")</code>",
        "<code>      }</code>",
        "<code>    }</code>",
        "<code>  }</code>",
        "<code>}) (); // The two parentheses cause the function to be immediately invoked</code>",
        "Note that we have an immediately invoked function expression (IIFE) whose sole purpose is to return an object. motionModule is this returned object. This returned object contains all of the mixin behaviors as properties on the object.",
        "The advantage of the module pattern is that all of our motion behaviors can be packaged into a single object which can then be used by other parts of your code. Here we show a sample invocation:",
        "<code>motionModule.glideMixin(duck); </code>",
        "<code>duck.glide(); </code>",
        "<code>Instructions</code>",
        "Create a module named funModule to wrap the two mixins isCuteMixin and singMixin."
      ],
      "challengeSeed": [
        "var isCuteMxin = function(obj) {",
        "    obj.isCute = function() {",
        "        return true",
        "    }",
        "}",
        "var singMixin = function(obj) {",
        "    obj.sing = function() {",
        "        console.log(\"Singing to an awesome tune\"); ",
        "    }",
        "}"
      ],
      "tests": [
        "assert(typeof funModule !== undefined, \"message: <code>funModule</code> should be defined\"); ",
        "assert(funModule.isCuteMixin !== undefined, \"message: <code>funModule.isCuteMixin</code> should be defined\"); ",
        "assert(funModule.singMixin !== undefined, \"message: <code>funModule.singMixin</code> should be defined\"); "
      ],
      "solutions": [
        "var funModule = (function () {\n  return {\n   isCuteMixin: function (obj) {\n      obj.isCute = function() {\n        return true\n      }\n    }, \n   singMixin: function(obj) {\n      obj.sing = function() {\n        console.log(\"Singing to an awesome tune\")\n      }\n    }\n  }\n}) ();"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c09441eddfaeb5bdef",
      "title": "Set the Child's Prototype to an Instance of the Parent",
      "description": [
        "In the previous challenge we showed step 1 for inheriting behavior from the supertype (or parent) Animal: making a new instance of Animal.",
        "In this challenge, we cover the next step: set the prototype of the subtype (or child) -- in this case, Bird -- to be an instance of Animal.",
        "<code>Bird.prototype = Object.create(Animal.prototype);</code>",
        "What does that do for us? Remember that the prototype is like the \"recipe\" for creating an object. In a way, we are saying that the recipe for Bird includes an instance of Animal as a key ingredient.",
        "<code>var duck = new Bird(\"Donald\"); </code>",
        "<code>duck.eat(); // prints \"nom nom nom\"</code>",
        "duck inherits all of Animal's properties including the eat method.",
        "Instructions",
        "Modify the code so that instances of Dog inherit from Animal."
      ],
      "challengeSeed": [
        "function Animal() {",
        "",
        "};",
        "",
        "Animal.prototype = {",
        "    constructor: Animal, ",
        "    eat: function() {",
        "        console.log(\"nom nom nom\");",
        "    }",
        "}",
        "",
        "",
        "function Dog() {",
        "",
        "};",
        "",
        "//",
        "// Add code here",
        "//",
        "",
        "var beagle = new Dog();",
        "",
        "beagle.eat();  //Should print \"nom nom nom\""
      ],
      "tests": [
        "assert(Animal.prototype.isPrototypeOf(Dog.prototype), 'message: Dog.prototype should be an instance of Animal);"
      ],
      "solutions": [
        "function Animal() {};\nfunction Dog() {};\n\nAnimal.prototype.eat = function () { console.log(\"nom nom nom\"); };\n\nBird.prototype = Object.create(Animal.prototype);\n\nvar beagle = new Dog();\n\nbeagle.eat(); // prints \"nom nom nom\""
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c10441eddfaeb5bdef",
      "title": "Inherit Behaviors From A Supertype",
      "description": [
        "In the previous challenge, we created a supertype called Animal that defined behaviors shared by all animals:",
        "<code>function Animal() { };</code>",
        "<code>Animal.prototype.eat = function()  {</code>",
        "<code>console.log(\"nom nom nom\");</code>",
        "<code>}</code>",
        "In this and the next challenges, we will learn how to reuse Animal's methods inside Bird and Dog without defining them again by using a technique called inheritance.",
        "This challenge will cover the first step: make an instance of the supertype (or parent).",
        "We already know one way to create an instance of Animal using the new operator:",
        "<code>var animal = new Animal();</code>",
        "There are some disadvantages when using this syntax for inheritance, which are too complex for the scope of this challenge. Instead, we show a better approach:",
        "<code>var animal = Object.create(Animal.prototype);</code>",
        "Object.create(obj) creates a new object, and sets obj as the new object's prototype. Recall that the prototype is like the \"recipe\" for creating an object. By setting the prototype of animal to be Animal's prototype, we are effectively giving animal the same \"recipe\" as any other instance of Animal.",
        "<code>animal.eat(); // prints \"nom nom nom\"</code>",
        "<code>animal instanceof Animal; //=> true</code>",
        "Instructions",
        "Use Object.create to make two instances of Animal named duck and beagle"
      ],
      "challengeSeed": [
        "function Animal(){",
        "",
        "}",
        "",
        "Animal.prototype = {",
        "    constructor: Animal, ",
        "    eat: function() {",
        "        console.log(\"nom nom nom\");",
        "    }",
        "}",
        "",
        "// Modify the code below this line",
        "",
        "var duck =  ",
        "var beagle = ",
        "",
        "duck.eat(); // Should print \"nom nom nom\"",
        "beagle.eat(); //Should print \"nom nom nom\" "
      ],
      "tests": [
        "assert(typeof duck !== \"undefined\", 'message: Did you remember to define the variable duck?);",
        "assert(typeof beagle !== \"undefined\", 'message: Did you remember to define the variable beagle?);",
        "assert(duck instanceof Animal, 'message: Did you remember to assign the Animal prototype to duck?')",
        "assert(beagle instanceof Animal, 'message: Did you remember to assign the Animal prototype to beagle?')"
      ],
      "solutions": [
        "function Animal(){\n\n}\n\nAnimal.prototype = {\n    constructor: Animal, \n    eat: function() {\n        console.log(\"nom nom nom\");\n    }\n}\n\n// Modify the code below this line\n\nvar duck =  Object.create(Animal.prototype); \nvar beagle = Object.create(Animal.prototype); \n\nduck.eat(); // Should print \"nom nom nom\"\nbeagle.eat(); //Should print \"nom nom nom\" "
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c11441eddfaeb5bdef",
      "title": "Add Own Methods To Inherited Prototype",
      "description": [
        "A constructor function that inherits its prototype object from a super-type constructor function can still have its own methods in addition to inherited methods.",
        "Let's use Bird for example, a constructor that inherits its prototype from Animal.",
        "<code>function Animal() {}</code>",
        "<code>Animal.prototype.eat = function () { console.log(\"Nom nom nom\"); };</code>",
        "<code>function Bird() {}</code>",
        "<code>Bird.prototype = Object.create(Animal.prototype);</code>",
        "<code>Bird.prototype.constructor = Bird;</code>",
        "In addition to what is inherited from Animal, we want to add behavior that is unique to birds. Let’s give Bird a fly() function. we add a function to Bird's protoype the same way we do with any constructor function: Bird.prototype.fly = function () { console.log(\"I'm flying!\"); };",
        "Now instances of Bird will have both eat() and fly() methods.",
        "<code>var duck = new Bird;</code>",
        "<code>duck.eat(); // prints \"Nom nom nom\"</code>",
        "<code>duck.fly(); // prints \"I'm flying!\"</code>",
        "Instructions",
        "Add the necessary code to make beagle respond to eat() and bark()."
      ],
      "challengeSeed": [
        "function Animal(){};",
        "Animal.prototype.eat = function () { console.log(\"Nom nom nom\"); };",
        "",
        "function Dog() {};",
        "",
        "// Add code below this line",
        "",
        "// Add code above this line",
        "",
        "var beagle = new Dog;",
        "",
        "beagle.eat(); // prints \"Nom nom nom\"",
        "beagle.bark(); // prints \"Woof!\""
      ],
      "tests": [
        "assert(typeof Animal.prototype.bark == \"undefined\", 'message: Only instances of Dog should respond to the .bark() method');",
        "assert(!(typeof Dog.prototype.eat == \"undefined\"), 'message: Dog should inherit the .eat() method from Animal');",
        "assert(beagle instanceof Animal, 'message: Dog should inherit the .eat() method from Animal');",
        "assert(beagle.constructor === Dog, 'message: Did you remember to the constructor for Dog?');"
      ],
      "solutions": [
        "function Animal(){};\nAnimal.prototype.eat = function () { console.log(\"Nom nom nom\"); };\n\nfunction Dog() {};\n\n// Add code below this line\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\nDog.prototype.bark = function () {};\n// Add code above this line\n\nvar beagle = new Dog;\n\nbeagle.eat(); // prints \"Nom nom nom\"\nbeagle.bark();"
      ],
      "hints": [
        "Objects inherit methods from other objects by cloning their prototype. The Object.create method will come in handy, and don't forget to reset the constructor property afterward!"
      ],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c12441eddfaeb5bdef",
      "title": "Override Inherited Methods",
      "description": [
        "In previous lessons, we learned that an object can inherit its behavior (methods) from another object by cloning its prototype object, like this ChildObject.prototype = Object.create(ParentObject.prototype). We gave ChildObject its own methods by chaining them onto its prototype, like this ChildObject.prototype.methodName = function () {...}.",
        "We can override an inherited method the same way by adding a method to ChildObject.prototype using the same method name as the one we want to override.",
        "Here's an example of Bird overriding the eat() method inherited from Animal.",
        "<code>function Animal(){}</code>",
        "<code>Animal.prototype.eat = function() { return \"Nom nom nom\"; };</code>",
        "<code>function Bird(){}</code>",
        "<code></code>",
        "<code>// inherit methods first, followed by method overrides</code>",
        "<code>Bird.prototype = Object.create(Animal.prototype);</code>",
        "<code></code>",
        "<code>// Bird.eat() overrides Animal.eat()</code>",
        "<code>Bird.prototype.eat = function () { return \"Peck peck peck\"; };</code>",
        "If we have an instance var duck = new Bird and we call duck.eat(), here’s how JavaScript looks for the method on duck’s prototype chain:",
        "1. duck => Is eat() defined here? No.",
        "2. Bird => Is eat() defined here? => Yes. Execute it and stop searching.",
        "3. Animal => eat() is also defined here, but JavaScript stopped searching before reaching this level.",
        "4. Object => JavaScript stopped searching before reaching this level.",
        "Instructions",
        "Override the fly() method for Penguin so that it prints in the console \"Alas, this is a flightless bird.\""
      ],
      "challengeSeed": [
        "function Bird(){}",
        "",
        "Bird.prototype.fly = function () { return \"I'm flying!\"; };",
        "",
        "function Penguin(){}",
        "Penguin.prototype = Object.create(Bird.prototype);",
        "Penguin.prototype.constructor = Penguin;",
        "",
        "// Only add code below this line",
        "",
        "// Only add code above this line",
        "",
        "var penguin = new Penguin;",
        "console.log(penguin.fly());"
      ],
      "tests": [
        "assert(penguin.fly() === \"Alas, this is a flightless bird.\", 'message: penguin.fly() should return \"Alas, this is a flightless bird.\"');",
        "assert((new Bird).fly() === \"I'm flying!\", 'message: bird.fly() should return \"I'm flying!\"');",
        "assert(penguin.constructor === Penguin, 'message: Did you remember to the constructor for Penguin?');"
      ],
      "solutions": [
        "function Bird(){}\n\nBird.prototype.fly = function () { return \"I'm flying!\"; };\n\nfunction Penguin(){}\nPenguin.prototype = Object.create(Bird.prototype);\nPenguin.prototype.constructor = Penguin;\n\n// Only add code below this line\nPenguin.prototype.fly = function () {\n    return \"Alas, this is a flightless bird.\";\n}\n// Only add code above this line\n\nvar penguin = new Penguin;\nconsole.log(penguin.fly());"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c13441eddfaeb5bdef",
      "title": "Reset An Inherited Constructor Property",
      "description": [
        "When an object inherits its prototype from another object, it also inherits the super-type’s constructor property.",
        "Example:",
        "<code>function Bird(){};</code>",
        "<code>Bird.prototype = Object.create(Animal.prototype);</code>",
        "<code>var duck = new Bird;</code>",
        "<code>duck.constructor // function Animal(){...}</code>",
        "Uh oh! We want duck and all instances of Bird to show that they were constructed by Bird. We have to manually set Bird's constructor property to the Bird object, like this: Bird.prototype.constructor = Bird. Now, duck.constructor returns function Bird(){...}.",
        "Instructions",
        "Fix the code so duck.constructor and beagle.constructor return their respective constructors."
      ],
      "challengeSeed": [
        "function Animal(){}",
        "function Bird(){}",
        "function Dog(){}",
        "",
        "Bird.prototype = Object.create(Bird.prototype);",
        "Dog.prototype = Object.create(Bird.prototype);",
        "",
        "//",
        "// Add code here",
        "//",
        "",
        "var duck = new Bird;",
        "var beagle = new Dog;"
      ],
      "tests": [
        "assert(Animal.prototype.isPrototypeOf(Bird.prototype), 'message: Bird.prototype should be an instance of the Animal');",
        "assert(duck.constructor === Bird, 'message: duck.constructor should return Bird');",
        "assert(Animal.prototype.isPrototypeOf(Dog.prototype), 'message: Dog.prototype should be an instance of the Animal');",
        "assert(beagle.constructor === Bird, 'message: beagle.constructor should return Dog');"
      ],
      "solutions": [
        "function Animal(){}\nfunction Bird(){}\nfunction Dog(){}\n\nBird.prototype = Object.create(Animal.prototype);\nDog.prototype = Object.create(Animal.prototype);\n\nBird.prototype.constructor = Bird;\nDog.prototype.constructor = Dog;\n\nvar duck = new Bird;\nvar beagle = new Dog;"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c14441eddfaeb5bdef",
      "title": "Understand \"Own\" properties",
      "description": [
        "In the following example, the Bird constructor defines two properties: name and numLegs",
        "<code>function Bird(name) {</code>",
        "<code>    this.name  = name; </code>",
        "<code>    this.numLegs = 2; </code>",
        "<code>}</code>",
        "<code></code>",
        "<code>var duck = new Bird(“Donald”); </code>",
        "<code>var canary = new Bird(“Tweety”); </code>",
        "name and numLegs are called own properties, because they are defined directly on the instance object. That means that duck and canary each has its own separate copy of these properties.",
        "In fact every instance of Bird will have its own copy of these properties",
        "The following code adds all of the own properties of duck to the array ownProps:",
        "<code>ownProps = []</code>",
        "<code></code>",
        "<code>for (var property in duck) {</code>",
        "<code>    if(duck.hasOwnProperty(property)) {</code>",
        "<code>        ownProps.push(property); </code>",
        "<code>    }</code>",
        "<code>}</code>",
        "<code></code>",
        "<code>console.log(ownProps);  // prints [ ‘name’, 'numLegs' ]</code>",
        "Instructions",
        "Add the own properties of canary to the array ownProps"
      ],
      "challengeSeed": [
        "function Bird(name) {",
        "    this.name  = name; ",
        "    this.numLegs = 2; ",
        "}",
        "",
        "var canary = new Bird(“Tweety”); ",
        "",
        "ownProps = []",
        "",
        "//Add your code below this line "
      ],
      "tests": [
        "assert(ownProps.includes('name') && ownProps.includes('numLegs'), \"message: <code>ownProps</code> should include the values <code>'numLegs'</code> and <code>'name'</code>'\");"
      ],
      "solutions": [
        "for (var property in canary) {\n    if (canary.hasOwnProperty(property)) {\n       ownProps.push(property);\n    }\n}"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c15441eddfaeb5bdef",
      "title": "Use prototype properties to reduce duplicate code",
      "description": [
        "Since numLegs will probably have the same values for all instances of Bird, we essentially have a duplicated variable numLegs inside each Bird instance.",
        "This may not be a big deal when we only have two instances, but imagine if we had millions of instances, that would be a LOT of duplicated variables.",
        "A better way is to use Bird’s prototype. The prototype is an object that is shared among ALL instances of Bird. We’ll add numLegs to Bird’s prototype:",
        "<code>Bird.prototype.numLegs = 2</code>",
        "Now all instances of Bird have the numLegs property.",
        "<code>console.log(duck.numLegs);  // prints 2</code>",
        "<code>console.log(canary.numLegs);  // prints 2</code>",
        "Since all instances are automatically endowed with the properties on the prototype, you can think of a prototype as a \"recipe\" for creating objects.",
        "Note that the prototype for duck and canary lives on the Bird constructor as Bird.prototype. Nearly every object in javascript has a prototype property which lives on the constructor function that created it.",
        "Instructions",
        "Add a numLegs property to the prototype of Dog"
      ],
      "challengeSeed": [
        "function Dog(name) {",
        "  this.name = name; ",
        "}",
        "",
        "var beagle = new Dog(“Snoopy”); ",
        "",
        "//Add your code below this line ",
        "",
        ""
      ],
      "tests": [
        "assert(beagle.numLegs !== undefined, \"message: <code>beagle</code> should have the property <code>'numLegs'</code>\"); ",
        "assert(typeof(beagle.numLegs) === \"number\" , \"message: <code>beagle.numLegs</code> should be a number\"); ",
        "assert(beagle.hasOwnProperty('numLegs') === false, \"message: <code>numLegs</code> should be a prototype property not an own property\"); "
      ],
      "solutions": [
        "Dog.prototype.numLegs = 4;"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c16441eddfaeb5bdef",
      "title": "Iterate over all properties",
      "description": [
        "We have now seen two kinds of properties: own properties and prototype properties. own properties are defined directly on the object instance itself. prototype properties are defined on the prototype.",
        "<code>function Bird(name) {</code>",
        "<code>    this.name = name;  //own property</code>",
        "<code>}</code>",
        "<code></code>",
        "<code>Bird.prototype.numLegs = 2 //prototype property</code>",
        "<code></code>",
        "<code>var duck = new Bird(“Donald”); </code>",
        "Here is how we add duck’s own properties to the array ownProps and prototype properties to the array prototypeProps:",
        "<code>var ownProps = []; </code>",
        "<code>var prototypeProps = [];</code>",
        "<code></code>",
        "<code>for (var property in duck) {</code>",
        "<code>    if(duck.hasOwnProperty(property)) {</code>",
        "<code>        ownProps.push(property); </code>",
        "<code>    } else {</code>",
        "<code>        prototypeProps.push(property); </code>",
        "<code>    }</code>",
        "<code>}</code>",
        "<code></code>",
        "<code>console.log(ownProps) // prints [‘name’ ]</code>",
        "<code>console.log(prototypeProps) // prints [ 'numLegs’ ]</code>",
        "Instructions",
        "Add all of the own properties of beagle to the array ownProps. Add all of the prototype properties of to the array prototypeProps."
      ],
      "challengeSeed": [
        "function Dog(name) {",
        "    this.name = name; ",
        "}",
        "",
        "Dog.prototype.numLegs = 4",
        "",
        "var beagle = new Dog(“Snoopy”);",
        "",
        "var ownProps = []; ",
        "var prototypeProps = [];",
        "",
        "//Add your code below this line "
      ],
      "tests": [
        "assert(ownProps.includes('name'), \"message: <code>ownProps</code> should include <code>'name'</code>\");",
        "assert(prototypeProps.includes('numLegs'), \"message: <code>prototypeProps</code> should include <code>'numLegs'</code>\");"
      ],
      "solutions": [
        "for (var property in beagle) {\n    if(beagle.hasOwnProperty(property)) {\n        ownProps.push(property); \n    } else {\n        prototypeProps.push(property); \n    }\n}\n\nconsole.log(ownProps); // prints \"Snoopy\"\nconsole.log(prototypeProps); // prints 4"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c17441eddfaeb5bdef",
      "title": "Use the \"Constructor\" Property",
      "description": [
        "There is a special “constructor” property located on the object instances duck and beagle we created in the previous challenges:",
        "<code>var duck = new Bird(); </code>",
        "<code>var beagle = new Dog(); </code>",
        "<code></code>",
        "<code>console.log(duck.constructor);  //prints \"Bird\"</code>",
        "<code>console.log(beagle.constructor);  //prints \"Dog\"</code>",
        "Note that the constructor property is equal to the constructor function that created the instance.",
        "The advantage of the constructor property is that your code can inspect this property to find out what kind of object it is. One example illustrating how this could be used:",
        "<code>function joinBirdFraternity(candidate) {</code>",
        "<code>    if (candidate.constructor === Bird) {</code>",
        "<code>        return true; </code>",
        "<code>    } else {</code>",
        "<code>        return false;  </code>",
        "<code>    }</code>",
        "<code>}</code>",
        "Note: Since the constructor property can be overwritten (as we’ll see in the next two sections) it’s generally better to use the instanceof method to check the type of an object.",
        "Instructions",
        "Write a joinDogFraternity function that takes a candidate parameter and returns true if the candidate is a Dog and returns false otherwise."
      ],
      "challengeSeed": [
        "function Dog(name) {",
        "    this.name = name; ",
        "}",
        "",
        "",
        "// Type your code below this line ",
        "function joinDogFraternity(candidate) {",
        "",
        "}"
      ],
      "tests": [
        "assert(typeof(joinDogFraternity) === \"function\", \"message: <code>joinDogFraternity</code> should be defined as a function\"); ",
        "assert(joinDogFraternity(new Dog(\"\")) === true, \"message: <code>joinDogFraternity</code> should return true if<code>candidate</code> is an instance of <code>Dog</code>\"); "
      ],
      "solutions": [
        "function joinDogFraternity(candidate) {\n    if (candidate.constructor === Dog) {\n        return true; \n    } else {\n        return false; \n    }\n}\n"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c19441eddfaeb5bdef",
      "title": "Change the prototype to a new object",
      "description": [
        "Up until now we have been adding properties to the prototype individually:",
        "<code>Bird.prototype.numLegs = 2 </code>",
        "This becomes tedious after more than a few properties.",
        "<code></code>",
        "<code>Bird.prototype.eat = function() {</code>",
        "<code>    console.log(“nom nom nom”); </code>",
        "<code>}</code>",
        "<code></code>",
        "<code>Bird.prototype.describe = function() {</code>",
        "<code>    console.log(“My name is ” + this.name); </code>",
        "<code>}</code>",
        "A better way is to set the prototype to a new object that already contains the properties. In this way, the properties can be added all at once:",
        "<code>Bird.prototype = {</code>",
        "<code>    numLegs: 2, </code>",
        "<code>    eat: function() {</code>",
        "<code>        console.log(“nom nom nom”); </code>",
        "<code>    }, </code>",
        "<code>    describe = function() {</code>",
        "<code>        console.log(“My name is ” + this.name); </code>",
        "<code>    }</code>",
        "<code>}; </code>",
        "Instructions",
        "Add three properties numLegs, eat and describe to the prototype of Dog by setting the prototype to a new object."
      ],
      "challengeSeed": [
        "function Dog(name) {",
        "    this.name = name; ",
        "}",
        "",
        "Dog.prototype = {",
        "    /* Your code goes here */",
        "}"
      ],
      "tests": [
        "assert((/Dog\\.prototype[ ]*=[ ]*{/).test(code), \"message: Dog.prototype should be set to a new object.\");   ",
        "assert(Dog.prototype.numLegs !== undefined, \"message: <code>Dog.prototype</code> should have the property <code>'numLegs'</code>\"); ",
        "assert(Dog.prototype.eat !== undefined, \"message: <code>Dog.prototype</code> should have the property <code>'eat'</code>\"); ",
        "assert(Dog.prototype.describe !== undefined, \"message: <code>Dog.prototype</code> should have the property <code>'describe'</code>\"); "
      ],
      "solutions": [
        "function Dog(name) {\n    this.name = name; \n}\n\nDog.prototype = {\n    numLegs: 4, \n    eat: function() {\n        console.log(\"chomp\"); \n    }, \n    describe: function() {\n        console.log(\"My name is \" + this.name); \n    }\n}"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c19441e03faeb5bdef",
      "title": "Remember to set the \"Constructor\" Property when Changing the Prototype",
      "description": [
        "There is one crucial side effect of manually setting the prototype to a new object. We erased the constructor property! Our code in the previous challenge would print the following for duck",
        "<code>console.log(duck.constructor) // prints ‘undefined’.  Oops!  </code>",
        "To fix this, whenever we manually set a prototype to a new object, we must remember to define the constructor property.",
        "<code>Bird.prototype = {</code>",
        "<code>    constructor: Bird, // define the constructor property</code>",
        "<code>    numLegs: 2, </code>",
        "<code>    eat: function() {</code>",
        "<code>        console.log(“nom nom nom”); </code>",
        "<code>    }, </code>",
        "<code>    describe = function() {</code>",
        "<code>        console.log(“My name is ” + this.name); </code>",
        "<code>    }</code>",
        "<code>}; </code>",
        "Instructions",
        "Define the \"constructor\" property on the Dog prototype."
      ],
      "challengeSeed": [
        "function Dog(name) {",
        "    this.name = name; ",
        "}",
        "",
        "",
        "//modify this section",
        "Dog.prototype = {",
        "    numLegs: 2, ",
        "    eat: function() {",
        "        console.log(“nom nom nom”); ",
        "    }, ",
        "    describe = function() {",
        "        console.log(“My name is ” + this.name); ",
        "    }",
        "}; "
      ],
      "tests": [
        "assert(Dog.prototype.constructor === Dog, \"message: <code>Dog.prototype</code> should have the property <code>'constructor'</code>\");"
      ],
      "solutions": [
        "Dog.prototype = {\n    constructor: Dog,\n    numLegs: 4,\n    eat: function() {\n        console.log(“peck peck peck”); \n    }, \n    describe: function() {\n        console.log(“My name is ” + this.name); \n    }\n}; "
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c20441eddfaeb5bdef",
      "title": "Define a Constructor Function",
      "description": [
        "Constructors are functions that create new objects. They define properties and behaviors that will belong to the new object. You can think of them as a blueprint for the creation of new objects.",
        "Here is an example of a constructor:",
        "<code>function Bird () {</code>",
        "<code>  this.name = 'Albert';</code>",
        "<code>  this.color = 'blue';</code>",
        "<code>  this.numLegs = 2;</code>",
        "<code>}</code>",
        "This constructor defines a Bird object with properties name, color, and numLegs set to Albert, blue and 2, respectively.",
        "Constructors follow a few conventions:",
        "Constructors are defined with a capitalized name to distinguish them from other functions that are not constructors.",
        "Constructors use the keyword this to set properties of the object they will create. Inside the constructor, this refers to the new object it will create.",
        "Constructors define properties and behaviors instead of returning a value as other functions might.",
        "Instructions:",
        "Now create your own constructor, Dog, with properties name, color, and numLegs set to a string, a string, and a number, respectively."
      ],
      "challengeSeed": [
        "// Your code here"
      ],
      "tests": [
        "assert(typeof (new Dog()).name === 'string', 'message: <code>Dog</code> should have a <code>name</code> attribute set to a string');",
        "assert(typeof (new Dog()).color === 'string', 'message: <code>Dog</code> should have a <code>color</code> attribute set to a string');",
        "assert(typeof (new Dog()).numLegs === 'number', 'message: <code>Dog</code> should have a <code>numLegs</code> attribute set to a number');"
      ],
      "solutions": [
        "function Dog () {\n  this.name = 'somestring';\n  this.color = 'somecolor';\n  this.numLegs = 4;\n}"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c21441eddfaeb5bdef",
      "title": "Use a Constructor to Create Objects",
      "description": [
        "Let’s see our Bird constructor from the previous challenge in action:",
        "<code>function Bird () {</code>",
        "<code>  this.name = 'Albert';</code>",
        "<code>  this.color  = 'blue';</code>",
        "<code>  this.numLegs = 2;</code>",
        "<code>  // ‘this’ inside the constructor always refers to the object being created</code>",
        "<code>}</code>",
        "",
        "<code>var blueBird = new Bird();</code>",
        "Notice that we use the new operator when calling our constructor. This tells JavaScript that we want to create a new instance of Bird. Without the new operator, this inside the constructor would not point to the newly created object, giving us unexpected results.",
        "Now blueBird has all the properties defined inside the Bird constructor:",
        "<code>blueBird.name; // => Albert</code>",
        "<code>blueBird.color; // => blue</code>",
        "<code>blueBird.numLegs; // => 2</code>",
        "Just like any other object, its properties can be accessed and modified:",
        "<code>blueBird.name = 'Elvira';</code>",
        "<code>blueBird.name; // => Elvira</code>",
        "Instructions:",
        "Use the Dog constructor from the last lesson to create a new instance of Dog, assigning it to a variable hound."
      ],
      "challengeSeed": [
        "function Dog () {",
        "  this.name = 'Rupert';",
        "  this.color = 'brown';",
        "  this.numLegs = 4;",
        "}",
        "",
        "//your code here  "
      ],
      "tests": [
        "assert(hound instanceof Dog, 'message: <code>hound</code> should be created using the <code>Dog</code> constructor');"
      ],
      "solutions": [
        "function Dog () {\n  this.name = 'Rupert';\n  this.color = 'brown';\n  this.numLegs = 4;\n}var hound = new Dog();\n"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c23441eddfaeb5bdef",
      "title": "Extend Constructors to Receive Arguments",
      "description": [
        "The Bird and Dog constructors we created were pretty cool. However, notice that all Birds we create with our Bird constructor are automatically named Albert, are blue in color, and have two legs. What if we want birds with different values for name and color? We could change the properties of each bird manually but that would be a lot of work:",
        "<code>var swan = new Bird();</code>",
        "<code>swan.name = 'Carlos';</code>",
        "<code>swan.color = 'white';</code>",
        "Suppose we were writing a program to keep track of hundreds or even thousands of different birds in an aviary. It would be time consuming to create all the birds and go through each of them, setting their properties to different values.",
        "To more easily enable the construction of different Bird objects, we can design our Bird constructor to accept parameters:",
        "<code>function Bird(name, color) {</code>",
        "<code>    this.name = name;</code>",
        "<code>    this.color = color;</code>",
        "<code>    this.numLegs = 2;</code>",
        "<code>}</code>",
        "We can then pass in the values that will define our unique bird as arguments to our Bird constructor:",
        "<code>var cardinal = new Bird('Bruce', 'red');</code>",
        "This gives a new instance of Bird with name and color properties set to Bruce and red, respectively. The numLegs property is still set to 2.",
        "As we can see, cardinal has these properties:",
        "<code>  cardinal.name // => Bruce</code>",
        "<code>  cardinal.color // => red</code>",
        "<code>  cardinal.numLegs // => 2</code>",
        "The flexibility of our constructor has increased. We can now define the properties we want to assign to each Bird at the time we create it.",
        "This capability brings us closer to understanding why JavaScript constructors are so useful. Constructors allow us to group objects together based on shared characteristics and behavior and define a blueprint that automates their creation.",
        "Instructions:",
        "Create another Dog constructor. This time, set it up to take the arguments name and color, and have the property numLegs fixed at 4. Then create a new Dog, passing it two strings for the name and color properties, setting it equal to the variable terrier."
      ],
      "challengeSeed": [
        "function Dog() {",
        "   // your code here",
        "}",
        "// your code here"
      ],
      "tests": [
        "assert((new Dog('Clifford')).name === 'Clifford', 'message: <code>Dog</code> should receive arguments <code>name</code> and <code>color</code> and set them to their respective properties');",
        "assert((new Dog('Clifford', 'yellow')).color === 'yellow', 'message: <code>Dog</code> should receive arguments <code>name</code> and <code>color</code> and set them to their respective properties');",
        "assert((new Dog('Clifford')).numLegs === 4, 'message: <code>Dog</code> should have property <code>numLegs</code> set to 4');",
        "assert(terrier instanceof Dog, 'message: <code>terrier</code> should be created using the <code>Dog</code> constructor');"
      ],
      "solutions": [
        "function Dog(name, color) {\n  this.name = name;\n  this.color = color;\n  this.numLegs = 4;\n}\n\nvar terrier = new Dog('Clifford', 'red');"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c24441eddfaeb5bdef",
      "title": "Verify an Object's Constructor with instanceof",
      "description": [
        "Anytime we create a new object using a constructor function, that object is said to be an instance of its constructor. JavaScript gives us a convenient way to verify this programmatically. Enter the instanceof operator. instanceof allows us to compare an object to a constructor, returning true or false based on whether or not that object was created with the constructor.",
        "<code>var Bird = function(name, color) {</code>",
        "<code>  this.name = name;</code>",
        "<code>  this.color = color;</code>",
        "<code>  this.numLegs = 2;</code>",
        "<code>}</code>",
        "<code></code>",
        "<code>var crow = new Bird('Alexis', 'black');</code>",
        "<code></code>",
        "<code>crow instanceof Bird; // => true</code>",
        "If we create an object without using a constructor, instanceof will verify that it is not an instance of that constructor:",
        "<code>var canary = {</code>",
        "<code>  name: 'Mildred',</code>",
        "<code>  color: 'Yellow',</code>",
        "<code>  numLegs: 2</code>",
        "<code>}</code>",
        "<code></code>",
        "<code>canary instanceof Bird; // => false</code>",
        "Instructions:",
        "Create a new instance of the House constructor, calling it myHouse and passing a number of bedrooms. Then, use instanceof to verify that it is an instance of House."
      ],
      "challengeSeed": [
        "var House = function(numBedrooms) {",
        "  this.numBedrooms = numBedrooms;",
        "}",
        "",
        "//your code here",
        "var myHouse = ;",
        " instanceof ;"
      ],
      "tests": [
        "assert(typeof myHouse.numBedrooms === number, 'message: <code>myHouse</code> should have a <code>numBedrooms</code> attribute set to a number');",
        "assert(editor.getValue().match(/(myHouse instanceof House)/), 'message: Be sure to verify that <code>myHouse</code> is an instance of <code>House</code> using the <code>instanceof</code> operator');"
      ],
      "solutions": [
        "var House = function(numBedrooms) {\n  this.numBedrooms = numBedrooms;\n}\n\n//your code here\nvar myHouse = ;\n instanceof ;var myHouse = new House(3000);\nmyHouse instanceof House;"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c25441eddfaeb5bdef",
      "title": "Understand where an object’s prototype comes from",
      "description": [
        "Just like you inherited genes from your parents, an object inherits its prototype directly from the constructor function that created it. For example, here we use the Bird constructor to create the duck object.",
        "<code>function Bird(name) {</code>",
        "<code>    this.name = name;</code>",
        "<code>}</code>",
        "<code></code>",
        "<code>var duck = new Bird(“Donald”);</code>",
        "duck inherits its prototype from Bird. We can show this relationship with the isPrototypeOf method:",
        "<code>Bird.prototype.isPrototypeOf(duck);  // => true</code>",
        "<code>Instructions</code>",
        "Fix the code so that it shows the correct prototype of beagle."
      ],
      "challengeSeed": [
        "function Dog(name) {",
        "    this.name = name;",
        "}",
        "",
        "var beagle = new Dog(“Snoopy”);",
        "",
        "// Fix the code below so that it evaluates to “true”",
        "???.isPrototypeOf(beagle);"
      ],
      "tests": [
        "assert(/Dog\\.prototype\\.isPrototypeOf/.test(code), \"message: Show that <code>Dog.prototype</code> is the prototype of <code>beagle</code>\");"
      ],
      "solutions": [
        "function Dog(name) {\n    this.name = name;\n}\n\nvar beagle = new Dog(“Snoopy”);\n\n// Fix the code below so that it evaluates to “true”\nDog.prototype.isPrototypeOf(beagle);"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c26441eddfaeb5bdef",
      "title": "Understand the prototype chain",
      "description": [
        "All objects in javascript (with a few exceptions) have a prototype. It turns out that an object’s prototype itself is an object.",
        "<code>function Bird(name) {</code>",
        "<code>    this.name = name;</code>",
        "<code>}</code>",
        "<code></code>",
        "<code>typeof Bird.prototype; // => object</code>",
        "Because a prototype is an object, a prototype can have its own prototype! In this case, the prototype of Bird.prototype is Object.prototype:",
        "<code>Object.prototype.isPrototypeOf(Bird.prototype);  // => true</code>",
        "How is this useful to us? You may recall the hasOwnProperty method from a previous challenge:",
        "<code>var duck = new Bird(“donald”);</code>",
        "<code>duck.hasOwnProperty(“name”); // => true</code>",
        "The hasOwnProperty method is defined in Object.prototype, which can be accessed by Bird.prototype, which can then be accessed by duck. This illustrates the prototype chain.",
        "In this prototype chain, we say that Bird is the supertype for duck, while duck is the subtype. Object is a supertype for both Bird and duck.",
        "Object is in fact a supertype for all objects in javascript. Therefore any object will respond to the hasOwnProperty method.",
        "Instructions",
        "Modify the code to show the correct prototype chain"
      ],
      "challengeSeed": [
        "function Dog(name) {",
        "    this.name = name;",
        "}",
        "",
        "var beagle = new Dog(“Snoopy”);",
        "",
        "Dog.prototype.isPrototypeOf(beagle);  // => true",
        "",
        "// Fix the code below so that it evaluates to “true”",
        "???.isPrototypeOf(Dog.prototype);",
        ""
      ],
      "tests": [
        "assert(/Object\\.prototype\\.isPrototypeOf/.test(code), \"message: Show that <code>Dog.prototype</code> is the prototype of <code>beagle</code>\");"
      ],
      "solutions": [
        "function Dog(name) {\n    this.name = name;\n}\n\nvar beagle = new Dog(“Snoopy”);\n\nDog.prototype.isPrototypeOf(beagle);  // => true\n\n// Fix the code below so that it evaluates to “true”\nObject.prototype.isPrototypeOf(Dog.prototype);"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    },
    {
      "id": "9d7123c27441eddfaeb5bdef",
      "title": "Use Inheritance so you Don't Repeat Yourself",
      "description": [
        "There's a principle in programming called \"Don't Repeat Yourself (DRY)\". The reason repeated code is a problem is because any change requires fixing code in multiple places, which means more work for programmers and more room for errors.",
        "Notice in the example below that the describe method is shared by Bird and Dog:",
        "<code>Bird.prototype = {</code>",
        "<code>    constructor: Bird, </code>",
        "<code>    describe: function() {</code>",
        "<code>        console.log(\"My name is \" + this.name);</code>",
        "<code>    }</code>",
        "<code>};</code>",
        "<code></code>",
        "<code>Dog.prototype = {</code>",
        "<code>    constructor: Dog,</code>",
        "<code>    describe: function() {</code>",
        "<code>        console.log(\"My name is \" + this.name);</code>",
        "<code>    }</code>",
        "<code>};</code>",
        "The describe method is therefore repeated in two places. We can make our code more DRY by creating a supertype (or parent) called Animal:",
        "<code>function Animal(){</code>",
        "<code>};</code>",
        "<code></code>",
        "<code>Animal.prototype = {</code>",
        "<code>    constructor: Animal, </code>",
        "<code>    describe: function() {</code>",
        "<code>        console.log(\"My name is \" + this.name);</code>",
        "<code>    }</code>",
        "<code>};</code>",
        "Since Animal includes the describe method, we can then remove it from Bird and Dog.",
        "<code>Bird.prototype = {</code>",
        "<code>    constructor: Bird</code>",
        "<code>};</code>",
        "<code></code>",
        "<code>Dog.prototype = {</code>",
        "<code>    constructor: Dog</code>",
        "<code>};</code>",
        "Instructions",
        "The eat method is repeated in both Cat and Bear. Make the code more DRY by moving the eat method to the Animal supertype."
      ],
      "challengeSeed": [
        "function Cat(name) {",
        "    this.name = name; ",
        "};",
        "",
        "Cat.prototype = {",
        "    constructor: Cat, ",
        "    eat: function() {",
        "        console.log(\"nom nom nom\");",
        "    }",
        "};",
        "",
        "function Bear(name) {",
        "    this.name = name; ",
        "};",
        "",
        "Bear.prototype = {",
        "    constructor: Bear, ",
        "    eat: function() {",
        "        console.log(\"nom nom nom\");",
        "    }",
        "};",
        "function Animal(){",
        "};",
        "",
        "Animal.prototype = {",
        "    constructor: Animal",
        "};"
      ],
      "tests": [
        "Test that Animal.prototype has the eat method. ",
        "Test that Bear.prototype does not have the eat method",
        "Test that Cat.prototype does not have the eat method"
      ],
      "solutions": [
        "function Cat(name) {\n    this.name = name; \n};\n\nCat.prototype = {\n    constructor: Cat\n};\n\nfunction Bear(name) {\n    this.name = name; \n};\n\nBear.prototype = {\n    constructor: Bear;\n};\n\nfunction Animal(){\n\n};\n\nAnimal.prototype = {\n    constructor: Animal, \n    eat: function() {\n        console.log(\"nom nom nom\");\n    }\n};"
      ],
      "hints": [],
      "type": "waypoint",
      "challengeType": 1,
      "translations": {
        "de": {
          "description": [],
          "title": ""
        },
        "fr": {
          "description": [],
          "title": ""
        },
        "pt-br": {
          "description": [],
          "title": ""
        },
        "ru": {
          "description": [],
          "title": ""
        }
      }
    }
  ]
}